<?php

/**
 * Wrapper for email function.
 * 
 * @author finke
 * @param string $to Send the email to this address.
 * @param string $subject The subject of the email.
 * @param string $body The body of the email.
 * @param array $extra_headers Any extra headers to include
 * @return object The object generated by email_object->send
 */

function email($to, $subject, $body, $extra_headers = null) {
	if (EMAIL_OVERRIDE) {
		$to = EMAIL_OVERRIDE;
	}
	
	$headers = array();
	$headers["From"] = "notifications@interpr.it";
	$headers["Reply-To"] = "chris@interpr.it";
	$headers["MIME-Version"] = "1.0";
	$headers["Content-Type"] = "text/html; charset=utf-8";
	
	if (is_array($extra_headers)) {
		$headers = array_merge($headers, $extra_headers);
	}
	
	$header_string = "";
	
	foreach ($headers as $name => $value) {
		$header_string .= $name . ": " . $value . "\n";
	}
	
	$header_string = trim($header_string);
	
	return mail($to, $subject, $body, $header_string);
}

function error_email($error, $file, $line) {
	try {
		$to = ADMIN_EMAIL;
		$subject = 'e10ni18n Error: Line '.$line.' of '.$file;
	
		$body = $error;
	
		$backtrace = debug_backtrace();
		array_shift($backtrace);
	
		$body .= "\n\n" . print_r($backtrace, true);
		$body .= "\n\nGET: ".print_r($_GET, true);
		$body .= "\n\nPOST: ".print_r($_POST, true);
		$body .= "\n\nSERVER: ".print_r($_SERVER, true);
		$body = '<pre>'.$body.'</pre>';
	
		email($to, $subject, $body);
	} catch (Exception $e) {
	}
}

function format_locale_code($locale_code, $extension_type = "crx") {
	if (!$locale_code) {
		return false;
	}
	
	$locale_code = str_replace("-", "_", $locale_code);
	$locale_code = strtolower($locale_code);
	
	$parts = explode("_", $locale_code);
	
	$code = $parts[0];
	
	if (count($parts) > 1) {
		$code .= "_" . strtoupper($parts[1]);
	}
	
	if ($extension_type == "xpi") {
		$code = str_replace("_", "-", $code);
	}
	
	return $code;
}

function locale_code_to_name($locale_code) {
	$locale_code = format_locale_code($locale_code);
	
	if (is_valid_locale($locale_code)) {
		return __("locale_name_" . $locale_code);
	}
	
	return "";
}

/**
 * @see http://www.php.net/manual/en/function.rmdir.php#98622
 */

function rrmdir($dir) {
	if (is_dir($dir)) {
		$objects = scandir($dir);
		
		foreach ($objects as $object) {
			if ($object != "." && $object != "..") {
				if (filetype($dir."/".$object) == "dir") {
					rrmdir($dir."/".$object); 
				}
				else {
					unlink($dir."/".$object);
				}
			}
		}
		
		reset($objects);
		
		rmdir($dir);
	}
}

function require_login() {
	if (sess_anonymous()) {
		header("Location: /signin?next=" . urlencode($_SERVER["REQUEST_URI"]));
		exit;
	}
}

/**
 * Returns the "slug" form of a string.  (Normalized, safe for URLs.)
 * 
 * @author finke
 * @param string $string The string to slugify.
 * @return string
 */

function slugify($string, $allow_underscores = false) {
	$slug = $string;
	
	$slug = str_replace(array(".","'"), "", $slug);
	$slug = str_replace(" & ", " and ", $slug);
	$slug = strtolower($slug);

	$foreign = array(chr(128),chr(129),chr(130),chr(131),chr(132),chr(133),chr(134),chr(135),chr(136),chr(137),chr(138),chr(139),chr(140),  
	  chr(141),chr(142),chr(143),chr(144),chr(145),chr(146),chr(147),chr(148),chr(149),chr(150),chr(151),chr(152),chr(153),chr(154),chr(155),
	  chr(156),chr(157),chr(158),chr(159),chr(160),chr(161),chr(162),chr(163),chr(164),chr(165),chr(166),chr(167),chr(224),chr(225),chr(226),
	  chr(227),chr(228),chr(229),chr(230),chr(231),chr(232),chr(233),chr(234),chr(235));
	$translated = array('c' , 'u' , 'e' , 'a' , 'a' , 'a' , 'a' , 'c' , 'e' , 'e' , 'i' , 'i' , 'i' , 'a' , 'a' , 'e' , 'ae' , 'ae' , 'o' , 'o' ,
	  'o' , 'u' , 'u' , 'y' , 'o' , 'u' , 'c' , 'l' , 'y' , 'p' , 'f' , 'a' , 'i' , 'o' , 'u' , 'n' , 'n' , 'a' , 'o' , 'a' , 'b' , 'r' , 'p' , 'e' ,
	  'o' , 'u' , 't' , 'r' , 'o' , 'o' , 'o');

	$slug = str_replace($foreign, $translated, $slug);
	
	if ($allow_underscores) {
		$regex = "/[^0-9a-z_]/";
	}
	else {
		$regex = "/[^0-9a-z]/";
	}

	$slug = preg_replace($regex, "-", $slug);
	$slug = preg_replace("/-+/", "-", $slug);
	$slug = preg_replace("/^-+|-+$/", "", $slug);
	
	return $slug;
}

/**
 * Converts \u0001 type escapes into proper unicode characters.
 *
 * @see http://stackoverflow.com/questions/2934563/how-to-decode-unicode-escape-sequences-like-u00ed-to-proper-utf-8-encoded-char
 */

function convert_unicode_escapes($text) {
	return preg_replace_callback('/\\\\u([0-9a-f]{4})/i', 'replace_unicode_escape_sequence', $text);
}

/**
 * Helper function from convert_unicode_escapes.
 */
function replace_unicode_escape_sequence($match) {
    return mb_convert_encoding(pack('H*', $match[1]), 'UTF-8', 'UTF-16BE');
}

function convert_to_unicode($str) {
	if (!mb_check_encoding($str, "UTF-8")) {
		$str = mb_convert_encoding($str, "UTF-8");
	}
	
	return $str;
}

/**
 * Pretty-prints JSON.
 *
 * @param string $json The JSON to beautify.
 * @param string $tab The "tab" character - can be a number of spaces as well.
 * @return string The formatted code.
 */

function json_format($json, $tab = "\t"){
    $new_json = "";
    $indent_level = 0;
    $in_string = false;

    $json_obj = json_decode($json);

    if($json_obj === false)
        return false;

    $json = json_encode($json_obj);
    $len = strlen($json);

    for($c = 0; $c < $len; $c++)
    {
        $char = $json[$c];
        switch($char)
        {
            case '{':
            case '[':
                if(!$in_string)
                {
                    $new_json .= $char . "\n" . str_repeat($tab, $indent_level+1);
                    $indent_level++;
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case '}':
            case ']':
                if(!$in_string)
                {
                    $indent_level--;
                    $new_json .= "\n" . str_repeat($tab, $indent_level) . $char;
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case ',':
                if(!$in_string)
                {
                    $new_json .= ",\n" . str_repeat($tab, $indent_level);
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case ':':
                if(!$in_string)
                {
                    $new_json .= ": ";
                }
                else
                {
                    $new_json .= $char;
                }
                break;
            case '"':
                if($c > 0 && $json[$c-1] != '\\')
                {
                    $in_string = !$in_string;
                }
            default:
                $new_json .= $char;
                break;                   
        }
    }

    return $new_json;
}

/**
 * Sanitizes user input for output.
 */

function san($str) {
	// Convert it to UTF-8.
	$str = mb_convert_encoding($str, 'UTF-8', mb_detect_encoding($str));
	return htmlspecialchars($str, ENT_COMPAT, 'UTF-8');
}

/**
 * Generates a random string.
 * 
 * @param int $length The length of the string to return.
 * @return string The random string.
 */

function random_string($length) {
	$alphabet = "ABCDEF0123456789";
	$alphabet_length = strlen($alphabet);
	
	$rv = "";
	
	for ($i = 0; $i < $length; $i++) {
		$rv .= $alphabet{rand(0, $alphabet_length)};
	}
	
	return $rv;
}

/**
 * Translates a string to the current locale.
 *
 * @param string $key The name of the string to translate.
 * @param array[string] $substitutions An array of data to fill in placeholders.
 * @return string The translated string.
 */

function __($key, $substitutions = array()) {
	$strings = $GLOBALS["strings"];
	
	$message = "";
	
	if (isset($strings->{$key})) {
		$bundle = $strings->{$key};
		$message = $bundle->message;
		
		$message = san($message);
		
		if (isset($bundle->placeholders)) {
			foreach ($bundle->placeholders as $i => $placeholder) {
				$message = preg_replace("/\\$" . $i . "\\$/Ui", preg_replace("/\\$([0-9])/U", "\\\\$$1", $placeholder->content), $message);
			}
		}
		
		if ($substitutions) {
			if (!is_array($substitutions)) {
				$substitutions = array( $substitutions );
			}
			
			for ($i = 0, $_len = count($substitutions); $i < $_len; $i++) {
				$message = preg_replace("/\\$" . ($i+1) . "/Ui", $substitutions[$i], $message);
			}
		}
	}
	else {
		$message = $key;
	}
	
	return nl2br($message);
}

/**
 * Parses the Accept-Language HTTP header into a list of locale codes and priorities.
 *
 * @see http://www.thefutureoftheweb.com/blog/use-accept-language-header
 * @param string $header The Accept-Language header strings.
 * @return array An array of locale codes and priorities.
 */

function parse_accept_language_header($header) {
	$rv = array();
	
	if ($header) {
		$matches = array();
		
		// break up string into pieces (languages and q factors)
		preg_match_all('/([a-z]{1,8}(-[a-z]{1,8})?)\s*(;\s*q\s*=\s*(1|0\.[0-9]+))?/i', $header, $matches);
		
		if (count($matches[1])) {
			// create a list like "en" => 0.8
			$rv = array_combine($matches[1], $matches[4]);
			
			// set default to 1 for any without q factor
			foreach ($rv as $lang => $val) {
				if ($val === '') $rv[$lang] = 1;
			}
			
			// sort list based on value	
			arsort($rv, SORT_NUMERIC);
		}
	}
	
	return $rv;
}

?>